<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Trials of an Intel Quad Processor System: 4x E5-4650L from SuperMicro -</title><meta name=robots content="index,follow,noarchive"><meta name=description content="Trials of an Intel Quad Processor System: 4x E5-4650L from SuperMicro
In recent months at AnandTech we have tackled a few issues of dual processor systems for regular use, and whether having a dual processor system as a theoretical scientist may help or hinder various benchmark scenarios.&nbsp; For the problems that I encountered as a theoretical physical chemist, using a dual processor system without any form of formal training dealing with memory allocation (NUMA) resulted in a severe performance hit for anything that required a significant level of memory accesses, especially grid solvers that required pulling information from large arrays held in memory."><meta name=author content="Larita Shotwell"><link rel="preload stylesheet" as=style href=https://assets.cdnweb.info/hugo/paper/css/app.css><link rel="preload stylesheet" as=style href=https://assets.cdnweb.info/hugo/paper/css/an-old-hope.min.css><script defer src=https://assets.cdnweb.info/hugo/paper/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=./theme.png><link rel=icon href=./favicon.ico><link rel=apple-touch-icon href=./apple-touch-icon.png><meta name=generator content="Hugo 0.98.0"><meta property="og:title" content="Trials of an Intel Quad Processor System: 4x E5-4650L from SuperMicro"><meta property="og:description" content="Trials of an Intel Quad Processor System: 4x E5-4650L from SuperMicro In recent months at AnandTech we have tackled a few issues of dual processor systems for regular use, and whether having a dual processor system as a theoretical scientist may help or hinder various benchmark scenarios. For the problems that I encountered as a"><meta property="og:type" content="article"><meta property="og:url" content="/trials-of-an-intel-quad-processor-system-4x-e54650l-from-supermicro.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-06-05T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-05T00:00:00+00:00"><meta itemprop=name content="Trials of an Intel Quad Processor System: 4x E5-4650L from SuperMicro"><meta itemprop=description content="Trials of an Intel Quad Processor System: 4x E5-4650L from SuperMicro In recent months at AnandTech we have tackled a few issues of dual processor systems for regular use, and whether having a dual processor system as a theoretical scientist may help or hinder various benchmark scenarios. For the problems that I encountered as a"><meta itemprop=datePublished content="2024-06-05T00:00:00+00:00"><meta itemprop=dateModified content="2024-06-05T00:00:00+00:00"><meta itemprop=wordCount content="1877"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Trials of an Intel Quad Processor System: 4x E5-4650L from SuperMicro"><meta name=twitter:description content="Trials of an Intel Quad Processor System: 4x E5-4650L from SuperMicro In recent months at AnandTech we have tackled a few issues of dual processor systems for regular use, and whether having a dual processor system as a theoretical scientist may help or hinder various benchmark scenarios. For the problems that I encountered as a"></head><body class=not-ready data-menu=true><header class=header><p class=logo><a class=site-name href=./index.html>PicoVlog</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>{bodyClx[e?"add":"remove"]("dark"),localStorage.setItem("dark",e?"yes":"no")};setDark(darkVal?darkVal==="yes":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",e=>setDark(e.matches))</script><nav class=menu><a href=./sitemap.xml>Sitemap</a></nav></header><main class=main><article class=post-single><header class=post-title><p><time>Jun 5, 2024</time>
<span>Larita Shotwell</span></p><h1>Trials of an Intel Quad Processor System: 4x E5-4650L from SuperMicro</h1></header><section class=post-content><p><strong>Trials of an Intel Quad Processor System: 4x E5-4650L from SuperMicro</strong></p><p>In recent months at AnandTech we have tackled a few issues of dual processor systems for regular use, and whether having a dual processor system as a theoretical scientist may help or hinder various benchmark scenarios.&nbsp; For the problems that I encountered as a theoretical physical chemist, using a dual processor system without any form of formal training dealing with memory allocation (NUMA) resulted in a severe performance hit for anything that required a significant level of memory accesses, especially grid solvers that required pulling information from large arrays held in memory.&nbsp; Part of the issue was latency access dealing with data that was in the memory of the other CPU, and thus a formal training in writing NUMA code would be applicable for multi-processor systems.&nbsp; Nevertheless in my AnandTech testing we did see significant speedup when dealing with various ‘pre-built’ software scenarios such as video conversion using Xilisoft Video Converter, rendering using PovRay and our 3D Particle Movement Benchmark.</p><p>To take this testing one stage further, SuperMicro kindly agreed to loan me remote desktop access to one of their internal quad processor (4P) systems.&nbsp; The movement from 2P to 4P is almost strictly in the realms of business investment, except for a few Folding@home enthusiasts that have seen large gains moving to a quad processor AMD system using obscure buyers for motherboards and eBay for processors.&nbsp; But with 4P in the business realm, the software has to match that usage scenario and scale appropriately.</p><p>Our testing scenario will cover our server motherboard CPU tests only – as I only had remote desktop access I was not fortunate enough to do any ‘gaming’ tests, although our gaming CPU article may have shown that unless you are doing a massive multi-screen multi-GPU setup then anything more than a single Sandy Bridge-E system may be overkill.</p><p><strong>Test Setup:</strong></p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/7121/8047R_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Supermicro <a href=#>X9QR7-TF+</a><br>4x Intel Xeon E5-4650L @ 2.6 GHz (3.1 GHz Turbo), 8 cores (16 threads) each<br>Kingston 128GB ECC DDR3-1600 C11<br>Windows Server Edition 2012 Standard</p><p><strong>Issues Encountered</strong></p><p>As you might imagine, moving from 1P to 2P and then to 4P without much experience in the field of multi-processor calculations was initially very daunting.&nbsp; The main issue moving to 4P was having an operating system that actually detected all the threads possible and then communicated that to software using the Windows APIs.&nbsp; In both Windows Server 2008 R2 Standard and 2012 Standard, the system would detect all 64 threads in task manager, but only report 32 threads to software.&nbsp; This raises a number of issues when dealing with software that automatically detects the number of threads on a system and only issues that number.&nbsp; In this scenario the user would need to manually set the number of threads, but it all depends on the way the program was written.&nbsp; For example, our Xilisoft and 3DPM tests do an automatic thread detection but set the threads to what is detected, whereas PovRay spawns a large number of threads despite automatic detection.&nbsp; Cinebench as well detected half the threads automatically, but at least has an option to spawn a custom number of threads.</p><p><strong>Point Calculations - 3D Movement Algorithm Test</strong></p><p>The algorithms in 3DPM employ both uniform random number generation or normal distribution random number generation, and vary in various amounts of trigonometric operations, conditional statements, generation and rejection, fused operations, etc.&nbsp; The benchmark runs through six algorithms for a specified number of particles and steps, and calculates the speed of each algorithm, then sums them all for a final score.&nbsp; This is an example of a real world situation that a computational scientist may find themselves in, rather than a pure synthetic benchmark.&nbsp; The benchmark is also parallel between particles simulated, and we test the single thread performance as well as the multi-threaded performance.</p><p><img alt="3D Particle Movement Single Threaded" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph7121/56153.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><img alt="3D Particle Movement MultiThreaded" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph7121/56154.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>The 3DPM test falls under the half-thread detection issue, and as a result of the high threads but lower single core speed we only just get an improvement over a 2P Westmere-EP system.&nbsp; For single thread performance the single thread speed of the E5-4650L (3.1 GHz) is too low to compete with other Sandy Bridge and above processors.</p><p><strong>Compression - WinRAR 4.2</strong></p><p>With 64-bit WinRAR, we compress the set of files used in the USB speed tests. WinRAR x64 3.93 attempts to use multithreading when possible, and provides as a good test for when a system has variable threaded load.&nbsp; WinRAR 4.2 does this a lot better! If a system has multiple speeds to invoke at different loading, the switching between those speeds will determine how well the system will do.</p><p><img alt="WinRAR 3.93" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph7121/56155.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><img alt="WinRAR 4.2" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph7121/56156.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>As WinRAR is ultimately dependent on memory speed, the 1600 C11 runs into the issues that the lower memory speed situations face.&nbsp; Despite this, the 2P Westmere-EP system still beats the 4P but you really need a good single core system with high bandwidth memory to take advantage.</p><p><strong>Image Manipulation - FastStone Image Viewer 4.2</strong></p><p>FastStone Image Viewer is a free piece of software I have been using for quite a few years now.&nbsp; It allows quick viewing of flat images, as well as resizing, changing color depth, adding simple text or simple filters.&nbsp; It also has a bulk image conversion tool, which we use here.&nbsp; The software currently operates only in single-thread mode, which should change in later versions of the software.&nbsp; For this test, we convert a series of 170 files, of various resolutions, dimensions and types (of a total size of 163MB), all to the .gif format of 640x480 dimensions.</p><p><img alt="FastStone Image Viewer 4.2" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph7121/56157.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>MHz and IPC wins for FastStone, which the single thread speed of the E5-4650Ls do not have.</p><p><strong>Video Conversion - Xilisoft Video Converter 7</strong></p><p>With XVC, users can convert any type of normal video to any compatible format for smartphones, tablets and other devices.&nbsp; By default, it uses all available threads on the system, and in the presence of appropriate graphics cards, can utilize CUDA for NVIDIA GPUs as well as AMD WinAPP for AMD GPUs.&nbsp; For this test, we use a set of 33 HD videos, each lasting 30 seconds, and convert them from 1080p to an iPod H.264 video format using just the CPU.&nbsp; The time taken to convert these videos gives us our result.</p><p><img alt="Xilisoft Video Converter 7" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph7121/56158.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>Due to the nature of XVC we do not see any speed up against Westmere-EP due to the 33rd video only being assigned a single thread, essentially doubling the time of the conversion.</p><p><strong>Rendering – PovRay 3.7</strong></p><p>The Persistence of Vision RayTracer, or PovRay, is a freeware package for as the name suggests, ray tracing.&nbsp; It is a pure renderer, rather than modeling software, but the latest beta version contains a handy benchmark for stressing all processing threads on a platform. We have been using this test in motherboard reviews to test memory stability at various CPU speeds to good effect – if it passes the test, the IMC in the CPU is stable for a given CPU speed.&nbsp; As a CPU test, it runs for approximately 2-3 minutes on high end platforms.</p><p><img alt="PovRay 3.7 Multithreaded Benchmark" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph7121/56159.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>PovRay is the first benchmark that shows the full strength of 64 Intel threads, scoring almost double that of the 24 thread Westmere-EP system (which was at higher frequency).</p><p><strong>Video Conversion - x264 HD Benchmark</strong></p><p>The x264 HD Benchmark uses a common HD encoding tool to process an HD MPEG2 source at 1280x720 at 3963 Kbps.&nbsp; This test represents a standardized result which can be compared across other reviews, and is dependent on both CPU power and memory speed.&nbsp; The benchmark performs a 2-pass encode, and the results shown are the average of each pass performed four times.</p><p><img alt="x264 HD Benchmark Pass 1" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph7121/56160.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><img alt="x264 HD Benchmark Pass 2" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph7121/56161.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>The issue with memory management and NUMA comes into effect with x264, and the complex memory accesses required over the QPI links put a dent in performance.</p><p><strong>Grid Solvers - Explicit Finite Difference</strong></p><p>For any grid of regular nodes, the simplest way to calculate the next time step is to use the values of those around it.&nbsp; This makes for easy mathematics and parallel simulation, as each node calculated is only dependent on the previous time step, not the nodes around it on the current calculated time step.&nbsp; By choosing a regular grid, we reduce the levels of memory access required for irregular grids.&nbsp; We test both 2D and 3D explicit finite difference simulations with 2n nodes in each dimension, using OpenMP as the threading operator in single precision.&nbsp; The grid is isotropic and the boundary conditions are sinks.&nbsp; Values are floating point, with memory cache sizes and speeds playing a part in the overall score.</p><p><img alt="Explicit Finite Difference Grid Solver (2D)" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph7121/56162.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><img alt="Explicit Finite Difference Grid Solver (3D)" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph7121/56163.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>It seems odd to consider that a 4P system might be detrimental to a computationally intensive benchmark, but it all boils down to learning how to code for the system you are simulating.&nbsp; Porting code written for a single CPU system onto a multiprocessor workstation is not a simple matter of copy-paste-done.</p><p><strong>Grid Solvers - Implicit Finite Difference + Alternating Direction Implicit Method</strong></p><p>The implicit method takes a different approach to the explicit method – instead of considering one unknown in the new time step to be calculated from known elements in the previous time step, we consider that an old point can influence several new points by way of simultaneous equations.&nbsp; This adds to the complexity of the simulation – the grid of nodes is solved as a series of rows and columns rather than points, reducing the parallel nature of the simulation by a dimension and drastically increasing the memory requirements of each thread.&nbsp; The upside, as noted above, is the less stringent stability rules related to time steps and grid spacing.&nbsp; For this we simulate a 2D grid of 2n nodes in each dimension, using OpenMP in single precision.&nbsp; Again our grid is isotropic with the boundaries acting as sinks. Values are floating point, with memory cache sizes and speeds playing a part in the overall score.</p><p><img alt="Implicit Finite Difference Grid Solver (2D)" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph7121/56164.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p><strong>Conclusions – Learn How To Code!</strong></p><p>For users considering multiprocessor systems, consider your usage scenario.&nbsp; If your simulation contains highly independent elements and lightweight threads, then the obvious suggestion is to look at GPUs for your needs.&nbsp; For all other purposes it is a lot easier to consider single CPU systems but scaling may occur if we look at memory management.&nbsp;</p><p>This makes sense when compiling your own code – the issue gets a lot tougher when dealing with third-party software.&nbsp; Before spending on a large multiprocessor system, get details from the company that make your software (for which you or your institution may be paying a large amount in yearly licensing fees) about whether it is suitable for multiprocessor systems, and do not be satisfied with answers such as ‘I don’t see why not’.</p><p>With Crystalwell in the picture in the consumer space, it becomes a lot more complex when dealing with a large eDRAM/L4 cache in a multiprocessor system.&nbsp; The system will then need to manage the snooping protocols for larger amounts of memory, making the whole procedure a nightmare for the unfortunate team that might have to deal with it.&nbsp; Crystalwell makes sense in the server space for single processor systems, perhaps dealing with MPI in clusters, but it might take a while to see it in the multiprocessor world at least.&nbsp; Fingers crossed…!</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZIRyfpBoq6uhkaHAbrvFZpinZZmjwaa4jKqsmpxdpb%2Bwr8SsqqiqXajGtMDEpmRtsF2agnWClGmjZp6ipLpuv9SpnKulmZi%2FsA%3D%3D</p></section><nav class=post-nav><a class=prev href=./netflixs-embarrassingly-ill-judged-blockbuster-epic-occupies-the-1-spot-in-54-countries-despite-being-annihilated-by-abysmal-reviews.html><span>←</span><span>Netflixs embarrassingly ill-judged blockbuster epic occupies the #1 spot in 54 countries despite</span></a>
<a class=next href=./does-brick-have-an-r-value-html.html><span>Does brick have an R value?</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2024 <a href=./></a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p></footer><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/banner.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>